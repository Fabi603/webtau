<mdoc>
  <entry>
    <url>/webtau/guide</url>
    <fullTitle>WebTau WebTau</fullTitle>
    <text>
      <text>WebTau ( Web   T est  au tomation) - Java API and Groovy Framework to test: Web REST Web UI import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("simple get") {
    http.get("/weather") {
        temperature.should == 88
    }
} import static com.twosigma.webtau.WebTauGroovyDsl.*
import static pages.Pages.*

scenario("""# Search facts
Enter a fact in a search box and 
information will be displayed in a special box
""") {
    search.open()
    search.submit(query: "search this")

    search.numberOfResults.should == 2
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/getting-started#installation</url>
    <fullTitle>WebTau: Getting Started, Installation [REST]</fullTitle>
    <text>
      <text>Download and unzip  https://github.com/twosigma/webtau/releases/ webtau . Add it to your  PATH .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/getting-started#bare-minimum</url>
    <fullTitle>WebTau: Getting Started, Bare Minimum [REST]</fullTitle>
    <text>
      <text>package rest

import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("simple get") {
    http.get("/weather") {
        temperature.should == 88
    }
} To run test, navigate to  examples  dir and webtau rest/restGet.groovy --url=https://my-server Note: using  package  and  import  is optional and is mainly for IDE auto completion. Imports will be added implicitly during command line run.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/getting-started#config-file</url>
    <fullTitle>WebTau: Getting Started, Config File [REST]</fullTitle>
    <text>
      <text>Url parameter can be moved to a  webtau.cfg  file. url = "http://localhost:8180" configuration/environments Specify multiple environments  to streamline test execution.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#example</url>
    <fullTitle>WebTau: CRUD, Example [REST]</fullTitle>
    <text>
      <text>We have an app that exposes create, read, update, and delete operations for customer records. Records are being served under  /customers . Here is an example of a  CRUD  operations test. package rest.springboot

import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("CRUD operations for customer") {
    def customerPayload = [firstName: "FN", lastName: "LN"]

    int id = http.post("/customers", customerPayload) {
        return id // return id value from response body
    }

    http.get("/customers/${id}") {
        body.should == customerPayload // only specified properties will be asserted against
    }

    def changedLastName = "NLN"
    http.put("/customers/${id}", [*:customerPayload, lastName: changedLastName]) {
        lastName.should == changedLastName // specifying body is optional
    }

    http.get("/customers/${id}") {
        lastName.should == changedLastName
    }

    http.delete("/customers/${id}") {
        statusCode.should == 204
    }

    http.get("/customers/${id}") {
        statusCode.should == 404
    }
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#implicit-statuscode-check</url>
    <fullTitle>WebTau: CRUD, Implicit statusCode Check [REST]</fullTitle>
    <text>
      <text>If you don't have an explicit  statusCode  validation it will be automatically validated based on the rules below Method Expected Code [{text=GET, type=SimpleText}] [{text=200, type=SimpleText}] [{text=POST, type=SimpleText}] [{text=201, type=SimpleText}] [{text=PUT, type=SimpleText}] [{text=200, type=SimpleText}] [{text=PUT (no content), type=SimpleText}] [{text=204, type=SimpleText}] [{text=DELETE, type=SimpleText}] [{text=200, type=SimpleText}] [{text=DELETE (no content), type=SimpleText}] [{text=204, type=SimpleText}]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#report</url>
    <fullTitle>WebTau: CRUD, Report [REST]</fullTitle>
    <text>
      <text>After your test executions a report will be produced. Note: asserted values are being tracked and highlighted inside the report</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#spring-boot</url>
    <fullTitle>WebTau: CRUD, Spring Boot [REST]</fullTitle>
    <text>
      <text>WebTau is framework agnostic. However, to make a concrete example, the  /customer   CRUD  endpoint is created by using  https://projects.spring.io/spring-boot/ Spring Boot . Three files are required to have a working REST endpoint with  CRUD  operations. Domain object package com.example.demo.springboot.app.data;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Customer {
    private Long id;
    private String firstName;
    private String lastName;

    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
} Repository package com.example.demo.springboot.app.data;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@Api(tags = "customer")
@RepositoryRestResource(collectionResourceRel = "customers", path = "customers")
public interface CustomerRepository extends JpaRepository&lt;Customer, Long> {
    @ApiOperation("find all customers ordered by last name")
    Iterable&lt;Customer> findAllByOrderByLastName();

    @Override
    void deleteAll();
} Entry point package com.example.demo.springboot.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@EnableJpaRepositories
@EnableSwagger2
@Import({springfox.documentation.spring.data.rest.configuration.SpringDataRestConfiguration.class})
public class SpringBootDemoApp {
    public static void main(String[] args) {
        SpringApplication.run(SpringBootDemoApp.class, args);
    }

    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                .build();
    }
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD-separated#lazy-resource</url>
    <fullTitle>WebTau: CRUD Separated, Lazy Resource [REST]</fullTitle>
    <text>
      <text>One of the benefits of separating one CRUD  scenario  into multiple is to be able to run one test at a time. In order to do it we will use  createLazyResource . package rest.springboot

import static com.twosigma.webtau.WebTauDsl.http
import static com.twosigma.webtau.WebTauGroovyDsl.createLazyResource
import static com.twosigma.webtau.WebTauGroovyDsl.scenario

class Customer {
    Number id
    String url // store url of the created entity
}

def customerPayload = [firstName: "FN", lastName: "LN"]

def customer = createLazyResource("customer") { // lazy resource to be created on the first access
    int id = http.post("/customers", customerPayload) {
        return id
    }

    return new Customer(id: id, url: "/customers/${id}")
}

scenario("customer create") {
    customer.id.should != null // accessing resource for the first time will trigger POST (in this example)
}

scenario("customer read") {
    http.get(customer.url) { // convenient re-use of url defined above
        body.should == customerPayload
    }
}

scenario("customer update") {
    def changedLastName = "NLN"
    http.put(customer.url, [*:customerPayload, lastName: changedLastName]) {
        lastName.should == changedLastName
    }

    http.get(customer.url) {
        lastName.should == changedLastName
    }
}

scenario("customer delete") {
    http.delete(customer.url) {
        statusCode.should == 204
    }

    http.get(customer.url) {
        statusCode.should == 404
    }
} Note: to run one scenario at a time use  sscenario  (additional  s  in front)</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD-separated#report</url>
    <fullTitle>WebTau: CRUD Separated, Report [REST]</fullTitle>
    <text>
      <text>As you can see in the report below, each  CRUD  operation has its own entry. If you follow this pattern, then you can filter tests by  create ,  update ,  read ,  delete  to streamline investigation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#special-values</url>
    <fullTitle>WebTau: Data Node, Special Values [REST]</fullTitle>
    <text>
      <text>Values that you access inside validation block are special values of  DataNode  type. When you assert them using  should  statement they act as proxies that record every assertion you do.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#extracting-values</url>
    <fullTitle>WebTau: Data Node, Extracting Values [REST]</fullTitle>
    <text>
      <text>As you have seen in  REST/CRUD CRUD example  you can return values back from a validation block. When you return a value from a validation block, it automatically gets converted to its correspondent primitive. Note: asserting that value after returning will not track and associated assertions with the call anymore. Use it only to get values required for consequent test calls.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#find</url>
    <fullTitle>WebTau: Data Node, Find [REST]</fullTitle>
    <text>
      <text>Special values inside assertion block have convenient methods find  to find a single value and  findAll  to find all the values matching predicate Note: While values inside a predicate are normal values, the result of  find  and  findAll  is still  DataNode</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#collect</url>
    <fullTitle>WebTau: Data Node, Collect [REST]</fullTitle>
    <text>
      <text>Use  collect  to transform a collection of items</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#standard-header</url>
    <fullTitle>WebTau: Headers, Standard Header [REST]</fullTitle>
    <text>
      <text>Standard headers like  Content-Type  and  Accept  are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to  application/json .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#common-header</url>
    <fullTitle>WebTau: Headers, Common Header [REST]</fullTitle>
    <text>
      <text>If each http request requires the same header you can specify that header using  httpHeaderProvider . Common example is specifying authentication header. import rest.headers.auth.Auth

url = "http://localhost:8080"

httpHeaderProvider = Auth.&amp;authHeader Where  Auth.&amp;authHeader  is implemented as follows: package rest.headers.auth

import com.twosigma.webtau.console.ConsoleOutputs
import com.twosigma.webtau.http.HttpRequestHeader

class Auth {
    static HttpRequestHeader authHeader(String fullUrl, String url, HttpRequestHeader original) {
        ConsoleOutputs.out('auth header injection point')
        return original.merge([Authorization: 'Bearer &lt;token>'])
    }
} This removes implementation details from your tests and makes them less brittle.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#explicit-header</url>
    <fullTitle>WebTau: Headers, Explicit Header [REST]</fullTitle>
    <text>
      <text>To explicitly set header pass  http.header(values)  as an additional parameter. Additionally  http.header  accepts values as a map.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/files-upload#file-system-content</url>
    <fullTitle>WebTau: Files Upload, File System Content [REST]</fullTitle>
    <text>
      <text>In following examples backend expects a file passed as  multipart/form-data . File content is expected to be stored in  file  field. Backend responds with received file name and file description. To  POST  form data, you need to use the same  http.post  statement as you saw in previous examples. Second parameter should be  http.formData  instead of a map payload we used for  JSON . Use  http.formFile  to override file name that is being sent to the backend. Multiple form fields can be specified like in the example below.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/files-upload#in-memory-content</url>
    <fullTitle>WebTau: Files Upload, In-Memory Content [REST]</fullTitle>
    <text>
      <text>If your test already has content, you can explicitly pass it as is. Note: no file name is passed and this particular backend generated file name on your behalf. Use  http.formFile  to provide a file name</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#scenarios</url>
    <fullTitle>WebTau: Documentation, Scenarios [REST]</fullTitle>
    <text>
      <text>You provide  REST endpoints  so users can execute various scenarios. You need to test those scenarios and then document them. To automate the process, let's capture executed scenarios and use them inside your documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#test-artifacts</url>
    <fullTitle>WebTau: Documentation, Test Artifacts [REST]</fullTitle>
    <text>
      <text>To capture artifacts use  http.doc.capture : package rest

import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("extracting id after POST to use inside GET request") {
    def id = http.post("/employee", [firstName: 'FN', lastName: 'LN']) {
        return id
    }
    http.doc.capture('employee-post')

    http.get("/employee/$id") {
        firstName.should == 'FN'
        lastName.should == 'LN'
    }
    http.doc.capture('employee-get') // capture previous HTTP call into &lt;docDir>/employee-get
} An  employee-get  directory will be created with request and response data files. Directory will also contain a json file with an array containing paths of all the asserted values. By default, the directory will be created in the current working directory. To change it add  docPath  to your  webtau.cfg  file. url = "http://localhost:8180"

docPath = "../../doc-artifacts"</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#document-rest-calls</url>
    <fullTitle>WebTau: Documentation, Document REST calls [REST]</fullTitle>
    <text>
      <text>If you have user facing scenario tests, capture them and refer to them inside your documentation. Set your documentation build pipeline like below. Combine REST requests and responses with Open API generated specs for complete documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/complex-types#contain</url>
    <fullTitle>WebTau: Complex Types, Contain [REST]</fullTitle>
    <text>
      <text>Use  contain  matcher to test scenarios like search or list of recently created entries. This way you don't have to assume an existing state of your backend under test. Given the response, we want to make sure there is an entry with a specified  firstName  and  lastName . package rest.springboot

import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("list Customers and assert that it contains a specified entry") {
    http.get("/customers/search/findAllByOrderByLastName") {
        _embedded.customers.should contain([firstName: 'FN1', lastName: 'LN1'])
    }
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/complex-types#list-of-objects</url>
    <fullTitle>WebTau: Complex Types, List Of Objects [REST]</fullTitle>
    <text>
      <text>If you want to make sure that all the values in the list are what you need - use  TableData . package rest.springboot

import static com.twosigma.webtau.WebTauGroovyDsl.*

scenario("list Customers and assert with a Table Data") {
    http.delete("/customers")

    http.post("/customers", [firstName: "FN1", lastName: "LN1"])
    http.post("/customers", [firstName: "FN2", lastName: "LN2"])
    http.post("/customers", [firstName: "FN3", lastName: "LN3"])

    http.get("/customers/search/findAllByOrderByLastName") {
        _embedded.customers.should == ['firstName' | 'lastName'] {
                                       __________________________
                                             'FN1' |      'LN1'
                                             'FN2' |      'LN2'
                                             'FN3' |      'LN3' }
    }

    http.doc.capture('list-match')
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#validation</url>
    <fullTitle>WebTau: OpenAPI Spec, Validation [REST]</fullTitle>
    <text>
      <text>Webtau supports validation of responses against an  https://www.openapis.org/ OpenAPI specification .  This feature can be enabled by specifying the  openApiSpecUrl  configuration option.  This should be the URL to the specification against which to validate. url = "http://localhost:8080"
openApiSpecUrl = 'api-spec.json'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#current-limitations</url>
    <fullTitle>WebTau: OpenAPI Spec, Current limitations [REST]</fullTitle>
    <text>
      <text>OpenAPI specification support is still in its early stage.  It is fully functional but there are a few limitations to be aware of: webtau currently only supports OpenAPI specification v2 specification matching is currently done purely based on the path any HTTP requests which do not match any operation in the specification will not fail tests but will produce a warning on the console</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#validations-report</url>
    <fullTitle>WebTau: OpenAPI Spec, Validations report [REST]</fullTitle>
    <text>
      <text>The validation errors are reported in the same manner as assertion errors.  They are available in the output from the command line webtau runner: > executing HTTP POST http://localhost:8080/customers
 {
  "id": 1,
  "firstName": "FN",
  "lastName": "LN",
  "_links": {
    "self": {
      "href": "http://localhost:8080/customers/1"
    },
    "customer": {
      "href": "http://localhost:8080/customers/1"
    }
  }
 }
X failed executing HTTP POST http://localhost:8080/customers : 
API spec validation failure: ERROR - Response status 201 not defined for path ''.: []
[x] failed
java.lang.AssertionError: 
API spec validation failure: ERROR - Response status 201 not defined for path ''.: []
	at rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy:8)
	at rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy)



Total: 1,  Passed: 0,  Skipped: 0,  Failed: 1,  Errored: 0
 They are also available in the HTML report:</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#location</url>
    <fullTitle>WebTau: Report, Location [REST]</fullTitle>
    <text>
      <text>By default report is generated at  &lt;workingdir>/webtau.report.html . To change the location use  --reportPath  option.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#summary</url>
    <fullTitle>WebTau: Report, Summary [REST]</fullTitle>
    <text>
      <text>Out of the box report provides high level information like number of failed tests and HTTP Operations coverage.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#navigation</url>
    <fullTitle>WebTau: Report, Navigation [REST]</fullTitle>
    <text>
      <text>Report is a self contained single page application. Url tracks your navigation through screens, so you can share url with your teammates to narrow down a problem.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#additional-reports</url>
    <fullTitle>WebTau: Report, Additional Reports [REST]</fullTitle>
    <text>
      <text>To generate custom reports, or upload report data to your server, specify  reportGenerator  config property. import rest.report.Report

url = "http://localhost:8080"

reportGenerator = Report.&amp;generateReport Where  Report.&amp;generateReport  is implemented as following package rest.report

import com.twosigma.webtau.console.ConsoleOutputs
import com.twosigma.webtau.console.ansi.Color
import com.twosigma.webtau.report.ReportTestEntries

import static com.twosigma.webtau.WebTauDsl.cfg

class Report {
    static void generateReport(ReportTestEntries entries) {
        def reportPath = cfg.workingDir.resolve('report.txt')

        ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath)
        reportPath.toFile().text = entries.size()
    }
}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#response-mapping</url>
    <fullTitle>WebTau: Matchers, Response Mapping [REST]</fullTitle>
    <text>
      <text>Identifiers inside validation closure are automatically mapped to a response body. In case of an array response you need to access values using  body .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#should-and-should-not</url>
    <fullTitle>WebTau: Matchers, Should and Should Not [REST]</fullTitle>
    <text>
      <text>Matchers in webtau are triggered with  should  and  shouldNot  keywords. myValue.should contain(10)
myValue.shouldNot equal("hello")
 Some matchers have alternative shortcuts. myValue.should != 10
 Additionally  shouldBe  and  shouldNotBe  alias keywords are available to make certain matcher combinations easier to read myValue.shouldBe greaterThan(10)
myValue.shouldBe > 10
</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#equality</url>
    <fullTitle>WebTau: Matchers, Equality [REST]</fullTitle>
    <text>
      <text>Webtau defines its own set of equality rules to simplify testing.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#greaterlessequal</url>
    <fullTitle>WebTau: Matchers, Greater/Less/Equal [REST]</fullTitle>
    <text>
      <text>Standard operations  > ,  >= ,  &lt; ,  &lt;=  are supported as shortcuts for  greaterThan ,  greaterThanOrEqual ,  lessThan , and  lessThanOrEqual .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#contain</url>
    <fullTitle>WebTau: Matchers, Contain [REST]</fullTitle>
    <text>
      <text>Use  contain  when you cannot rely on order.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#date-and-time</url>
    <fullTitle>WebTau: Matchers, Date and Time [REST]</fullTitle>
    <text>
      <text>You can assert  actual  string against  LocalDate  and  ZonedDateTime . String will be automatically converted using ISO formatter.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#mixing-matchers</url>
    <fullTitle>WebTau: Matchers, Mixing Matchers [REST]</fullTitle>
    <text>
      <text>You can use matchers in place of expected values to build a more complex expectation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/configuration#base-url</url>
    <fullTitle>WebTau: Configuration, Base URL [UI]</fullTitle>
    <text>
      <text>Robust tests don't specify the full URL of an application under test. Instead you only pass a relative URL to functions like  open . Define base URL portion either inside a  webtau.cfg  file url = "http://localhost:8180"
userName = 'testUser'
environments {
   dev {
       url = "http://dev.host:8080"
   }
} or pass as a command line argument  --url=http://...</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/configuration#timeouts</url>
    <fullTitle>WebTau: Configuration, Timeouts [UI]</fullTitle>
    <text>
      <text>Default timeout in milliseconds for  waitTo  and  waitToNot waitTimeout = 25000
 --waitTimeout=25000
</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/configuration#window-size</url>
    <fullTitle>WebTau: Configuration, Window Size [UI]</fullTitle>
    <text>
      <text>Browser window size can be set using  windowWidth  and  windowHeight url = "http://localhost:8180"

windowWidth = 1280
windowHeight = 800</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/configuration#documentation-artifacts</url>
    <fullTitle>WebTau: Configuration, Documentation Artifacts [UI]</fullTitle>
    <text>
      <text>By default all generated documentation artifacts (e.g. screenshots) are created in the current directory. To override url = "http://localhost:8180"

docPath = "screenshots"</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/finders-and-filters#filters</url>
    <fullTitle>WebTau: Finders And Filters, Filters [UI]</fullTitle>
    <text>
      <text>&lt;div id="menu">
 &lt;ul> 
  &lt;li> &lt;a href="/book">book&lt;/a> &lt;/li> 
  &lt;li> &lt;a href="/orders">orders&lt;/a> &lt;/li> 
  &lt;li> &lt;a href="/help">help&lt;/a> &lt;/li> 
 &lt;/ul> 
&lt;/div> $("#menu ul li a").get("orders") 
$("#menu ul li a").get(~/orders/) 
$("#menu ul li a").get(2) 
</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#test-encapsulation</url>
    <fullTitle>WebTau: Page Object, Test Encapsulation [UI]</fullTitle>
    <text>
      <text>Robust tests should not depend on implementation details. UI has plenty of those: UI Elements placement Actions UI test should not depend on any of them. Move elements placement and available actions outside of UI test. Multiple tests can then reuse that information. And more importantly you will have only one place to change if UI changes.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#definition</url>
    <fullTitle>WebTau: Page Object, Definition [UI]</fullTitle>
    <text>
      <text>PageObject  is just a simple class. Usage of a special  action  method is optional. Used to add additional reporting information.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#grouping</url>
    <fullTitle>WebTau: Page Object, Grouping [UI]</fullTitle>
    <text>
      <text>To make it easier to refer  PageObjects  from different tests combine them in one file later just static import all of them</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-element#methods</url>
    <fullTitle>WebTau: Page Element, Methods [UI]</fullTitle>
    <text>
      <text>Below are the methods that are available on  PageElement  instance. Examples below refer following page object</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-element#assertions</url>
    <fullTitle>WebTau: Page Element, Assertions [UI]</fullTitle>
    <text>
      <text>waitTo Synchronization point with dynamic UI. Executes matcher multiple time until it matches or time runs out. search.open()
 waitToNot Synchronization point with dynamic UI. Executes negated matcher multiple time until it matches or time runs out. search.open()
 should Executes passed matcher against page element's underlying value search.open()
search.welcomeMessage.should == 'welcome to super search'
 shouldNot Executes negated matcher against page element's underlying value search.open()
search.welcomeMessage.shouldNot == 'welcome to boring search'
</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/matchers#values</url>
    <fullTitle>WebTau: Matchers, Values [UI]</fullTitle>
    <text>
      <text>regexp checks if an element or its value matches provided matcher search.open()
search.welcomeMessage.should == ~/welcome to \w+ search/
search.welcomeMessage.shouldNot == ~/welcome to \w+ S.*/
search.welcomeMessage.waitTo == ~/welcome to \w+ search/
search.welcomeMessage.waitToNot == ~/welcome to \w+ S.*/
</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/cli#overrides</url>
    <fullTitle>WebTau: Cli, Overrides [Configuration]</fullTitle>
    <text>
      <text>Any config file parameter can be overridden with a command line parameter. For example, given this config file: waitTimeout = 2500
url = http://my-server
 Values can be overridden as follows: webtau --waitTimeout=25000 --url=http://another-server</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/environments#select</url>
    <fullTitle>WebTau: Environments, Select [Configuration]</fullTitle>
    <text>
      <text>waitTimeout = 2500
url = http://my-server

environments {
   dev {
       url = "http://localhost:8080"
   }
}
 webtau --env=dev</text>
      <score>STANDARD</score>
    </text>
  </entry>
</mdoc>
