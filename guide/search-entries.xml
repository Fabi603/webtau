<mdoc>
  <entry>
    <url>/webtau/guide</url>
    <fullTitle>WebTau WebTau</fullTitle>
    <text>
      <text>WebTau (Web Test automation) - concise and expressive way to create REST API and Web UI tests. package scenarios.rest import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("simple get") { http.get("/weather") { temperature.shouldBe &lt; 100 } } package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario("search by specific query") { search.submit("search this") search.numberOfResults.should == 2 }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/getting-started#bare-minimum</url>
    <fullTitle>WebTau: Getting Started, Bare Minimum [REST]</fullTitle>
    <text>
      <text>package scenarios.rest import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("simple get") { http.get("/weather") { temperature.shouldBe &lt; 100 } } To run test, navigate to examples dir and webtau scenarios/rest/simpleGet.groovy --url=https://my-server</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/getting-started#config-file</url>
    <fullTitle>WebTau: Getting Started, Config File [REST]</fullTitle>
    <text>
      <text>Url parameter can be moved to a webtau.cfg file. url = "http://localhost:8180" configuration/environments Specify multiple environments to streamline test execution.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#example</url>
    <fullTitle>WebTau: CRUD, Example [REST]</fullTitle>
    <text>
      <text>We have an app that exposes create, read, update, and delete operations for customer records. Records are being served under /customers .Here is an example of a CRUD operations test. package scenarios.rest.springboot import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("CRUD operations for customer") { def customerPayload = [firstName: "FN", lastName: "LN"] int id = http.post("/customers", customerPayload) { return id // return id value from response body } http.get("/customers/${id}") { body.should == customerPayload // only specified properties will be asserted against } def changedLastName = "NLN" http.put("/customers/${id}", [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName // specifying body is optional } http.get("/customers/${id}") { lastName.should == changedLastName } http.delete("/customers/${id}") { statusCode.should == 204 } http.get("/customers/${id}") { statusCode.should == 404 } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#implicit-statuscode-check</url>
    <fullTitle>WebTau: CRUD, Implicit statusCode Check [REST]</fullTitle>
    <text>
      <text>If you don't have an explicit statusCode validation it will be automatically validated based on the rules below Method Expected Code [{text=GET, type=SimpleText}] [{text=200, type=SimpleText}] [{text=POST, type=SimpleText}] [{text=201, type=SimpleText}] [{text=PUT, type=SimpleText}] [{text=200, type=SimpleText}] [{text=PUT (no content), type=SimpleText}] [{text=204, type=SimpleText}] [{text=DELETE, type=SimpleText}] [{text=200, type=SimpleText}] [{text=DELETE (no content), type=SimpleText}] [{text=204, type=SimpleText}]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#report</url>
    <fullTitle>WebTau: CRUD, Report [REST]</fullTitle>
    <text>
      <text>After your test executions a report will be produced.Note: asserted values are being tracked and highlighted inside the report</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD#spring-boot</url>
    <fullTitle>WebTau: CRUD, Spring Boot [REST]</fullTitle>
    <text>
      <text>WebTau is framework agnostic. However, to make a concrete example, the /customer CRUD endpoint is created by using https://projects.spring.io/spring-boot/ Spring Boot.Three files are required to have a working REST endpoint with CRUD operations.Domain object package com.example.demo.springboot.app.data; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Customer { private Long id; private String firstName; private String lastName; @Id @GeneratedValue public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } } Repository package com.example.demo.springboot.app.data; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.rest.core.annotation.RepositoryRestResource; @Api(tags = "customer") @RepositoryRestResource(collectionResourceRel = "customers", path = "customers") public interface CustomerRepository extends JpaRepository&lt;Customer, Long> { @ApiOperation("find all customers ordered by last name") Iterable&lt;Customer> findAllByOrderByLastName(); } Entry point package com.example.demo.springboot.app; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Import; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @SpringBootApplication @EnableJpaRepositories @EnableSwagger2 @Import({springfox.documentation.spring.data.rest.configuration.SpringDataRestConfiguration.class}) public class SpringBootDemoApp { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApp.class, args); } @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD-separated#lazy-resource</url>
    <fullTitle>WebTau: CRUD Separated, Lazy Resource [REST]</fullTitle>
    <text>
      <text>One of the benefits of separating one CRUD scenario into multiple is to be able to run one test at a time. In order to do it we will use createLazyResource . package scenarios.rest.springboot import static com.twosigma.webtau.WebTauGroovyDsl.* class Customer { Number id String url // store url of the created entity } def customerPayload = [firstName: "FN", lastName: "LN"] def customer = createLazyResource("customer") { // lazy resource to be created on the first access int id = http.post("/customers", customerPayload) { return id } return new Customer(id: id, url: "/customers/${id}") } scenario("customer create") { customer.id.should != null // accessing resource for the first time will trigger POST (in this example) } scenario("customer read") { http.get(customer.url) { // convenient re-use of url defined above body.should == customerPayload } } scenario("customer update") { def changedLastName = "NLN" http.put(customer.url, [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName } http.get(customer.url) { lastName.should == changedLastName } } scenario("customer delete") { http.delete(customer.url) { statusCode.should == 204 } http.get(customer.url) { statusCode.should == 404 } } Note: to run one scenario at a time use sscenario (additional s in front)</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/CRUD-separated#report</url>
    <fullTitle>WebTau: CRUD Separated, Report [REST]</fullTitle>
    <text>
      <text>As you can see in the report below, each CRUD operation has its own entry. If you follow this pattern, then you can filter tests by create , update , read , delete to streamline investigation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#special-values</url>
    <fullTitle>WebTau: Data Node, Special Values [REST]</fullTitle>
    <text>
      <text>Values that you access inside validation block are special values of DataNode type. When you assert them using should statement they act as proxies that record every assertion that you do.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#extracting-values</url>
    <fullTitle>WebTau: Data Node, Extracting Values [REST]</fullTitle>
    <text>
      <text>As you have seen in REST/CRUD CRUD example you can return values back from a validation block.When you return a value from a validation block, it automatically gets converted to its correspondent primitive.Note: asserting that value after returning will not track and associated assertions with the call anymore. Use it only to get values required for consequent test calls.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#properties-on-lists</url>
    <fullTitle>WebTau: Data Node, Properties On Lists [REST]</fullTitle>
    <text>
      <text>If you have a list of objects like complexList above, you can access all its children property value with complexList.k2 .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#find</url>
    <fullTitle>WebTau: Data Node, Find [REST]</fullTitle>
    <text>
      <text>Special values inside assertion block have convenient methods find to find a single valueand findAll to find all the values matching predicateNote: While values inside a predicate are normal values, the result of find and findAll is still DataNode</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#collect</url>
    <fullTitle>WebTau: Data Node, Collect [REST]</fullTitle>
    <text>
      <text>Use collect to transform a collection of items</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/data-node#combine</url>
    <fullTitle>WebTau: Data Node, Combine [REST]</fullTitle>
    <text>
      <text>Methods find and collect can be chained</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#standard-header</url>
    <fullTitle>WebTau: Headers, Standard Header [REST]</fullTitle>
    <text>
      <text>Standard headers like Content-Type and Accept are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to application/json .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#common-header</url>
    <fullTitle>WebTau: Headers, Common Header [REST]</fullTitle>
    <text>
      <text>If each http request requires the same header you can specify that header using httpHeaderProvider . Common example is specifying authentication header. import scenarios.rest.headers.auth.Auth url = "http://localhost:8080" httpHeaderProvider = Auth.&amp;authHeader Where Auth.&amp;authHeader is implemented as follows: package scenarios.rest.headers.auth import com.twosigma.webtau.console.ConsoleOutputs import com.twosigma.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { ConsoleOutputs.out('auth header injection point') return original.merge([Authorization: 'Bearer &lt;token>']) } } This removes implementation details from your tests and makes them less brittle.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#explicit-header</url>
    <fullTitle>WebTau: Headers, Explicit Header [REST]</fullTitle>
    <text>
      <text>To explicitly set header pass http.header(values) as an additional parameter.Additionally http.header accepts values as a map.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#mime-type-combined-with-payload</url>
    <fullTitle>WebTau: Headers, Mime Type Combined With Payload [REST]</fullTitle>
    <text>
      <text>Use http.body to combine Content-Type and payload.If you need a standard type consider using</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/headers#response-header</url>
    <fullTitle>WebTau: Headers, Response Header [REST]</fullTitle>
    <text>
      <text>To validate values from response header use header object.At the moment only location , contentLocation , contentLength have camelCase shortcuts. All the other header values you need to use ['Header-Name'] syntax.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/files-upload#file-system-content</url>
    <fullTitle>WebTau: Files Upload, File System Content [REST]</fullTitle>
    <text>
      <text>In following examples backend expects a file passed as multipart/form-data . File content is expected to be stored in file field. Backend responds with received file name and file description.To POST form data, you need to use the same http.post statement as you saw in previous examples. Second parameter should be http.formData instead of a map payload we used for JSON .Use http.formFile to override file name that is being sent to the backend.Multiple form fields can be specified like in the example below.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/files-upload#in-memory-content</url>
    <fullTitle>WebTau: Files Upload, In-Memory Content [REST]</fullTitle>
    <text>
      <text>If your test already has content, you can explicitly pass it as is.Note: no file name is passed and this particular backend generated file name on your behalf.Use http.formFile to provide a file name</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/PDF#asserting-text</url>
    <fullTitle>WebTau: PDF, Asserting Text [REST]</fullTitle>
    <text>
      <text>If response contains a pdf file you can assert its content using pdf(body) function.If more than one assertion needs to be made, assign pdf result to a local variable.Note: use pdf assertions for sanity checks like presence of correct client names or account numbers. Leave comprehensive pdf generation test to unit tests.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#scenarios</url>
    <fullTitle>WebTau: Documentation, Scenarios [REST]</fullTitle>
    <text>
      <text>You provide REST endpoints so users can execute various scenarios. You need to test those scenarios and then document them.To automate the process, let's capture executed scenarios and use them inside your documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#test-artifacts</url>
    <fullTitle>WebTau: Documentation, Test Artifacts [REST]</fullTitle>
    <text>
      <text>To capture artifacts use http.doc.capture : package scenarios.rest import static com.twosigma.webtau.WebTauDsl.http import static com.twosigma.webtau.WebTauGroovyDsl.scenario scenario("extracting id after POST to use inside GET request") { def id = http.post("/employee", [firstName: 'FN', lastName: 'LN']) { return id } http.doc.capture('employee-post') http.get("/employee/$id") { firstName.should == 'FN' lastName.should == 'LN' } http.doc.capture('employee-get') // capture previous HTTP call into &lt;docDir>/employee-get } An employee-get directory will be created with request and response data files.Directory will also contain a json file with an array containing paths of all the asserted values.By default, the directory will be created in the current working directory. To change it add docPath to your webtau.cfg file. url = "http://localhost:8180" docPath = "doc-artifacts"</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/documentation#document-rest-calls</url>
    <fullTitle>WebTau: Documentation, Document REST calls [REST]</fullTitle>
    <text>
      <text>If you have user facing scenario tests, capture them and refer to them inside your documentation. Set your documentation build pipeline like below.Combine REST requests and responses with Open API generated specs for complete documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/complex-types#contain</url>
    <fullTitle>WebTau: Complex Types, Contain [REST]</fullTitle>
    <text>
      <text>Use contain matcher to test scenarios like search or list of recently created entries. This way you don't have to assume an existing state of your backend under test.Given the response, we want to make sure there is an entry with a specified firstName and lastName . package scenarios.rest.springboot import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("list Customers and assert that it contains a specified entry") { http.get("/customers/search/findAllByOrderByLastName") { _embedded.customers.should contain([firstName: 'FN1', lastName: 'LN1']) } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/complex-types#list-of-objects</url>
    <fullTitle>WebTau: Complex Types, List Of Objects [REST]</fullTitle>
    <text>
      <text>If you want to make sure that all the values in the list are what you need - use TableData . package scenarios.rest.springboot import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("list Customers and assert with a Table Data") { http.post("/customers", [firstName: "FN1", lastName: "LN1"]) http.post("/customers", [firstName: "FN2", lastName: "LN2"]) http.post("/customers", [firstName: "FN3", lastName: "LN3"]) http.get("/customers/search/findAllByOrderByLastName") { _embedded.customers.should == ['firstName' | 'lastName'] { __________________________ 'FN1' | 'LN1' 'FN2' | 'LN2' 'FN3' | 'LN3' } } http.doc.capture('list-match') }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#validation</url>
    <fullTitle>WebTau: OpenAPI Spec, Validation [REST]</fullTitle>
    <text>
      <text>Webtau supports validation of responses against an https://www.openapis.org/ OpenAPI specification. This feature can be enabled by specifying the openApiSpecUrl configuration option. This should be the URL to the specification against which to validate. url = "http://localhost:8080" openApiSpecUrl = 'api-spec.json'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#current-limitations</url>
    <fullTitle>WebTau: OpenAPI Spec, Current limitations [REST]</fullTitle>
    <text>
      <text>OpenAPI specification support is still in its early stage. It is fully functional but there are a few limitations to be aware of:webtau currently only supports OpenAPI specification v2specification matching is currently done purely based on the pathany HTTP requests which do not match any operation in the specification will not fail tests but will produce a warning on the console</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#validations-report</url>
    <fullTitle>WebTau: OpenAPI Spec, Validations report [REST]</fullTitle>
    <text>
      <text>The validation errors are reported in the same manner as assertion errors. They are available in the output from the command line webtau runner: bash > executing HTTP POST http://localhost:8080/customers { "id": 1, "firstName": "FN", "lastName": "LN", "_links": { "self": { "href": "http://localhost:8080/customers/1" }, "customer": { "href": "http://localhost:8080/customers/1" } } } X failed executing HTTP POST http://localhost:8080/customers : API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] [x] failed java.lang.AssertionError: API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy:8) at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy) Total: 1, Passed: 0, Skipped: 0, Failed: 1, Errored: 0 They are also available in the HTML report:</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/openAPI-spec#validation-configuration</url>
    <fullTitle>WebTau: OpenAPI Spec, Validation Configuration [REST]</fullTitle>
    <text>
      <text>To ignore additional properties in responses set openApiIgnoreAdditionalProperties to true . As any other config value it can be done via command line, config file or system properties.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/JSON-schema#validation</url>
    <fullTitle>WebTau: JSON Schema, Validation [REST]</fullTitle>
    <text>
      <text>Webtau supports validation of objects against https://json-schema.org/ JSON Schema. It is possible to validate either the entire body or just a specific field with the complyWithSchema matcher as shown in the two examples below:Both examples above validate against the following schema:</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/JSON-schema#error-messages</url>
    <fullTitle>WebTau: JSON Schema, Error messages [REST]</fullTitle>
    <text>
      <text>Using the first example above, an invalid schema will generate an error similar to: invalid schema (examples/scenarios/rest/jsonSchema/validateSchema.groovy) > executing HTTP GET http://localhost:8080/weather X failed expecting body to comply with schema invalid-schema.json : body expected to comply with schema invalid-schema.json [#: required key [anotherField] not found, #/temperature: expected type: Boolean, found: Integer] { "temperature": 88 } The schema used in validation to generate this error is as follows:</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/JSON-schema#configuration</url>
    <fullTitle>WebTau: JSON Schema, Configuration [REST]</fullTitle>
    <text>
      <text>The path to the schema file specified in complyWithSchema can be relative or absolute. If it's relative, it'll be relative to the jsonSchemasDir specified in configuration and if not specified then relative to working directory. For example: url = "http://localhost:8180" jsonSchemasDir = 'schemas'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#location</url>
    <fullTitle>WebTau: Report, Location [REST]</fullTitle>
    <text>
      <text>By default report is generated at &lt;workingdir>/webtau.report.html . To change the location use --reportPath option.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#summary</url>
    <fullTitle>WebTau: Report, Summary [REST]</fullTitle>
    <text>
      <text>Out of the box report provides high level information like number of failed tests and HTTP Operations coverage.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#navigation</url>
    <fullTitle>WebTau: Report, Navigation [REST]</fullTitle>
    <text>
      <text>Report is a self contained single page application. Url tracks your navigation through screens, so you can share url with your teammates to narrow down a problem.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/report#additional-reports</url>
    <fullTitle>WebTau: Report, Additional Reports [REST]</fullTitle>
    <text>
      <text>To generate custom reports, or upload report data to your server, specify reportGenerator config property. import scenarios.rest.report.Report url = "http://localhost:8080" reportGenerator = Report.&amp;generateReport Where Report.&amp;generateReport is implemented as following package scenarios.rest.report import com.twosigma.webtau.console.ConsoleOutputs import com.twosigma.webtau.console.ansi.Color import com.twosigma.webtau.report.ReportTestEntries import static com.twosigma.webtau.WebTauDsl.cfg class Report { static void generateReport(ReportTestEntries entries) { def reportPath = cfg.workingDir.resolve('report.txt') ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath) reportPath.toFile().text = entries.size() } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/maven#dependency</url>
    <fullTitle>WebTau: Maven, Dependency [REST]</fullTitle>
    <text>
      <text>You can use maven to add webtau as a dependency to you project (for autocompletion or to use with JUnit like runners). Groovy &lt;dependency> &lt;groupId>com.twosigma.webtau&lt;/groupId> &lt;artifactId>webtau-groovy&lt;/artifactId> &lt;version>1.5&lt;/version> &lt;/dependency> Java &lt;dependency> &lt;groupId>com.twosigma.webtau&lt;/groupId> &lt;artifactId>webtau&lt;/artifactId> &lt;version>1.5&lt;/version> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/maven#plugin</url>
    <fullTitle>WebTau: Maven, Plugin [REST]</fullTitle>
    <text>
      <text>Use maven plugin to run pure groovy tests as part of your build. &lt;plugin> &lt;groupId>com.twosigma.webtau&lt;/groupId> &lt;artifactId>webtau-maven-plugin&lt;/artifactId> &lt;version>1.5&lt;/version> &lt;executions> &lt;execution> &lt;phase>test&lt;/phase> &lt;goals> &lt;goal>run&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;configuration> &lt;workingDir>${project.basedir}/src/main/groovy&lt;/workingDir> &lt;env>integration&lt;/env> &lt;url>http://optional-base-url&lt;/url> &lt;tests> &lt;directory>${project.basedir}/src/main/groovy&lt;/directory> &lt;includes> &lt;include>scenarios/*.groovy&lt;/include> &lt;/includes> &lt;/tests> &lt;/configuration> &lt;/plugin> Use env to specify configuration/environments environment to use. Alternatively you can use url to override base url.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#imports-to-use</url>
    <fullTitle>WebTau: Matchers, Imports to use [REST]</fullTitle>
    <text>
      <text>For tests outside standard JVM runners like JUnit a single optional static import is all you need groovy import static com.twosigma.webtau.WebTauGroovyDsl.* For JUnit like pure HTTP tests groovy import static com.twosigma.webtau.Ddjt.* import static com.twosigma.webtau.http.Http.http</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#response-mapping</url>
    <fullTitle>WebTau: Matchers, Response Mapping [REST]</fullTitle>
    <text>
      <text>Identifiers inside validation closure are automatically mapped to a response body. Groovy Java http.get("/end-point-simple-object", (header, body) -> { body.get("k1").should(equal("v1")); }); List responses are handled by using index chain Groovy Note: Groovy API implicitly assumes body , but if you need to deal with array response you need to access values using body explicitly. Java http.get("/end-point-simple-list", (header, body) -> { body.get(0).get("k1").should(equal("v1")); });</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#should-and-should-not</url>
    <fullTitle>WebTau: Matchers, Should and Should Not [REST]</fullTitle>
    <text>
      <text>Matchers in webtau are triggered with should and shouldNot keywords. Additionally shouldBe and shouldNotBe alias keywords are available to make certain matcher combinations easier to read. Groovy Java http.get("/example", (header, body) -> { body.get("year").shouldNot(equal(2000)); body.get("genres").should(contain("RPG")); body.get("rating").shouldBe(greaterThan(7)); });</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#equality</url>
    <fullTitle>WebTau: Matchers, Equality [REST]</fullTitle>
    <text>
      <text>Webtau defines its own set of equality rules to simplify testing. Groovy Java http.get("/end-point", (header, body) -> { body.get("id").shouldNot(equal(0)); body.get("amount").should(equal(30)); body.get("list").should(equal(Arrays.asList(1, 2, 3))); body.get("object").get("k1").should(equal( Pattern.compile("v\\d"))); // regular expression matching body.get("object").should(equal(aMapOf( "k1", "v1", "k3", "v3"))); // matching only specified fields and can be nested multiple times body.get("complexList").should(equal(table("k1" , "k2").values( // matching only specified fields, but number of entries must be exact "v1" , 30, "v11", 40))); }); http.doc.capture("end-point-object-equality-matchers");</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#greaterlessequal</url>
    <fullTitle>WebTau: Matchers, Greater/Less/Equal [REST]</fullTitle>
    <text>
      <text>Use greaterThan , greaterThanOrEqual , lessThan , and lessThanOrEqual to assert numeric values. Groovy Note: Groovy can use shortcuts > , >= , &lt; , &lt;= . Java http.get("/end-point-numbers", (header, body) -> { body.get("id").shouldBe(greaterThan(0)); body.get("price").shouldBe(greaterThanOrEqual(100)); body.get("amount").shouldBe(lessThan(150)); body.get("list").get(1).shouldBe(lessThanOrEqual(2)); body.get("id").shouldNotBe(lessThanOrEqual(0)); body.get("price").shouldNotBe(lessThan(100)); body.get("amount").shouldNotBe(greaterThanOrEqual(150)); body.get("list").get(1).shouldNotBe(greaterThan(2)); }); http.doc.capture("end-point-numbers-matchers");</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#contain</url>
    <fullTitle>WebTau: Matchers, Contain [REST]</fullTitle>
    <text>
      <text>Use contain when you cannot rely on order of values in a response. Groovy Java http.get("/end-point-list", (header, body) -> { body.should(contain(aMapOf( "k1", "v1", "k2", "v2"))); body.get(1).get("k2").shouldNot(contain(22)); }); http.doc.capture("end-point-list-contain-matchers");</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#date-and-time</url>
    <fullTitle>WebTau: Matchers, Date and Time [REST]</fullTitle>
    <text>
      <text>You can assert actual string against LocalDate and ZonedDateTime . String will be automatically converted using ISO formatter. Groovy Java http.get("/end-point-dates", (header, body) -> { LocalDate expectedDate = LocalDate.of(2018, 6, 12); ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of("UTC")); body.get("tradeDate").should(equal(expectedDate)); body.get("transactionTime").should(equal(expectedTime)); body.get("transactionTime").shouldBe(greaterThanOrEqual(expectedDate)); body.get("paymentSchedule").should(contain(expectedDate)); }); http.doc.capture("end-point-dates-matchers");</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/matchers#mixing-matchers</url>
    <fullTitle>WebTau: Matchers, Mixing Matchers [REST]</fullTitle>
    <text>
      <text>You can use matchers in place of expected values to build a more complex expectation. Groovy Java Pattern withNumber = Pattern.compile("v\\d"); http.get("/end-point-mixed", (header, body) -> { body.get("list").should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value body.get("object").should(equal(aMapOf( "k1", "v1", "k3", withNumber))); // regular expression match against k3 body.get("complexList").get(0).should(equal(aMapOf( "k1", "v1", "k2", lessThan(120)))); // lessThen match against k2 body.get("complexList").get(1).should(equal(aMapOf( "k1", notEqual("v1"), // any value but v1 "k2", greaterThanOrEqual(120)))); TableData expected = table("k1", "k2").values( // matching only specified fields, but number of entries must be exact withNumber, lessThan(120), "v11", greaterThan(150)); body.get("complexList").should(equal(expected)); }); http.doc.capture("end-point-mixing-matchers");</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/test-execution#serial-execution</url>
    <fullTitle>WebTau: Test Execution, Serial execution [REST]</fullTitle>
    <text>
      <text>The default mode for running tests is serially; in other words, scenario files are executed one after the other.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/REST/test-execution#parallel-execution</url>
    <fullTitle>WebTau: Test Execution, Parallel execution [REST]</fullTitle>
    <text>
      <text>Webtau supports executing tests in parallel. In this mode, scenario files are executed in parallel. Individual scenarios are still executed sequentially.For large test suites, it is therefore advisable to create many small focused scenario files instead of few large files.To enable parallel execution, specify the numberOfThreads configuration property either through the configuration file or as a CLI parameter. This property dictates the maximum number of threads on which to run tests.Note: scenario file execution order is not guaranteed.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/getting-started#bare-minimum</url>
    <fullTitle>WebTau: Getting Started, Bare Minimum [UI]</fullTitle>
    <text>
      <text>package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* scenario('simple open') { browser.open("/search") $('#welcome').should == 'welcome to super search' } To run test, navigate to examples dir and webtau scenarios/ui/basic.groovy --url=https://my-server</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/getting-started#config-file</url>
    <fullTitle>WebTau: Getting Started, Config File [UI]</fullTitle>
    <text>
      <text>Url parameter can be moved to a webtau.cfg file. url = "http://localhost:8180" configuration/environments Specify multiple environments to streamline test execution.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/basic-configuration#base-url</url>
    <fullTitle>WebTau: Basic Configuration, Base URL [UI]</fullTitle>
    <text>
      <text>Robust tests don't specify the full URL of an application under test. Instead you only pass a relative URL to functions like open .Define base URL portion either inside a webtau.cfg file url = "http://localhost:8180" or pass as a command line argument --url=http://...</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-element-and-value#lazy-element</url>
    <fullTitle>WebTau: Page Element And Value, Lazy Element [UI]</fullTitle>
    <text>
      <text>When you use $('.css') you create instance of PageElement . PageElement represent an element that is present or will be present on a web page. It is safe to declare an element before you open a browser or navigate to the page you need to test. package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* def welcomeMessage = $('#welcome') scenario('simple open') { browser.open("/search") welcomeMessage.should == 'welcome to super search' }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-element-and-value#lazy-value</url>
    <fullTitle>WebTau: Page Element And Value, Lazy Value [UI]</fullTitle>
    <text>
      <text>Consider a simple search page. Enter value, hit enter, see results.Here is simple test. package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* scenario('search by specific query') { browser.open('/search') $('#search-box').setValue('search this') $('#search-box').sendKeys("\n") $('#results .result').count.shouldBe > 1 } In the example $('#results .result').count represents the number of elements matching the css selector. Let's extract it. package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* def searchBox = $('#search-box') def numberOfResults = searchBox.count scenario('search by specific query') { browser.open('/search') searchBox.setValue('search this') searchBox.sendKeys("\n") numberOfResults.shouldBe > 1 }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#test-encapsulation</url>
    <fullTitle>WebTau: Page Object, Test Encapsulation [UI]</fullTitle>
    <text>
      <text>Robust tests should not depend on implementation details. UI has plenty of those:UI Elements placementActionsUI test should not depend on any of them. Move elements placement and available actions outside of UI test. Multiple tests can then reuse that information. And more importantly you will have only one place to change if UI changes.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#definition</url>
    <fullTitle>WebTau: Page Object, Definition [UI]</fullTitle>
    <text>
      <text>To define PageObject create a class.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-object#grouping</url>
    <fullTitle>WebTau: Page Object, Grouping [UI]</fullTitle>
    <text>
      <text>To make it easier to refer PageObjects from different tests combine them in one fileUse static import to have seamless access to all of them</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#universal-set-value</url>
    <fullTitle>WebTau: Forms, Universal Set Value [UI]</fullTitle>
    <text>
      <text>Use setValue on a declared page element to set its value. It will work on all the standard input types out of the box.Define all the input fields inside a page object. In combination with universal setValue it will make your tests robust.Given a html snippet &lt;html> &lt;body> &lt;div id="form"> &lt;input id="name"/> &lt;input id="startDate" type="date"/> &lt;select id="rank"> &lt;option/> &lt;option value="A">A&lt;/option> &lt;option value="B">B&lt;/option> &lt;option value="C">C&lt;/option> &lt;option value="D">D&lt;/option> &lt;option value="E">E&lt;/option> &lt;/select> &lt;/div> &lt;/body> &lt;/html> Page object can be defined as package pages import static com.twosigma.webtau.WebTauDsl.* class FormPage { def name = $('#name') def rank = $('#rank') def startDate = $('#startDate') }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#default-input</url>
    <fullTitle>WebTau: Forms, Default Input [UI]</fullTitle>
    <text>
      <text>form.name.setValue('Full Automation')</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#date-input</url>
    <fullTitle>WebTau: Forms, Date Input [UI]</fullTitle>
    <text>
      <text>form.startDate.setValue('06/21/2016')</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#select</url>
    <fullTitle>WebTau: Forms, Select [UI]</fullTitle>
    <text>
      <text>form.rank.setValue('B')</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#universal-assert</url>
    <fullTitle>WebTau: Forms, Universal Assert [UI]</fullTitle>
    <text>
      <text>Form element value can be asserted the same way as any regular element. Underlying value will be extracted based on the element type form.name.should == 'Full Automation' form.rank.should == 'B' form.startDate.should == '2016-06-21'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/forms#custom-form-elements</url>
    <fullTitle>WebTau: Forms, Custom Form Elements [UI]</fullTitle>
    <text>
      <text>One of the benefits of universal set and assert is that your test is focused on the data and not implementation details. But what if you decided to use a custom component to enter the data?To hide implementation details from your test you should define a custom input handler for your UI component.Let's consider a form component that you can start interacting with only after you clicked it. And after the value is entered, the input box disappears again. &lt;div id="answer" class="special-selector" onclick="activate('answer')"> &lt;div class="current-value"> current value &lt;/div> &lt;input class="value-input" value="" onblur="valueEntered('answer')"> &lt;/div> Our test should still be written in terms of data entering and validation. def customFormElement = $('#answer') customFormElement.setValue('hello') customFormElement.should == 'hello' In order to achieve this we need to register a custom handler. import formHandlers.CustomInput url = "http://localhost:8180" pageElementGetSetValueHandlers = [CustomInput] package formHandlers import com.twosigma.webtau.browser.page.HtmlNode import com.twosigma.webtau.browser.page.PageElement import com.twosigma.webtau.browser.page.PageElementStepExecutor import com.twosigma.webtau.browser.page.value.handlers.PageElementGetSetValueHandler import com.twosigma.webtau.reporter.TokenizedMessage class CustomInput implements PageElementGetSetValueHandler { @Override boolean handles(HtmlNode htmlNode, PageElement pageElement) { return htmlNode.attributes.class =~ /special-selector/ } @Override void setValue(PageElementStepExecutor stepExecutor, TokenizedMessage pathDescription, HtmlNode htmlNode, PageElement pageElement, Object value) { pageElement.click() pageElement.find('input').sendKeys("${value}\t") } @Override String getValue(HtmlNode htmlNode, PageElement pageElement) { return pageElement.find('.current-value').getUnderlyingValue() } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/asynchronous-page#synchronization</url>
    <fullTitle>WebTau: Asynchronous Page, Synchronization [UI]</fullTitle>
    <text>
      <text>Many actions in a modern web page are asynchronous. User presses a button and a moment later a result appears. In modern web pages there is no full page reload and only a portion of a page will be changed.If a test will try to assert a value after a user action, chances are assertion will fail since it will take time for a result to appear on a page.Question: How do users know that their action is done and they can move on?</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/asynchronous-page#visiblehidden-element</url>
    <fullTitle>WebTau: Asynchronous Page, Visible/Hidden Element [UI]</fullTitle>
    <text>
      <text>One way to deal with asynchronous pages is to wait for a feedback to appear or disappear. calculation.start() calculation.feedback.waitTo beVisible() calculation.results.should == [100, 230]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/asynchronous-page#enableddisabled-element</url>
    <fullTitle>WebTau: Asynchronous Page, Enabled/Disabled Element [UI]</fullTitle>
    <text>
      <text>Disabled input box and buttons can be used as a user feedback as well. calculation.open() calculation.input.waitTo beEnabled() calculation.input.setValue(100)</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/asynchronous-page#wait-to-match</url>
    <fullTitle>WebTau: Asynchronous Page, Wait to match [UI]</fullTitle>
    <text>
      <text>If presence/absence of an element is not important, you can directly to wait for a matcher to match. calculation.start() calculation.results.waitTo == [100, 230] Note: any matcher that you can use with should and shouldNot can be used with waitTo and waitToNot</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/asynchronous-page#wait-on-url</url>
    <fullTitle>WebTau: Asynchronous Page, Wait on url [UI]</fullTitle>
    <text>
      <text>Another cue to use could be a url change after an action. browser.open('/resource-creation') $('#new').click() browser.url.ref.waitTo == 'created-id' Note: url exposes other parts that you can UI/navigation#assert-url read more about here</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/advanced-configuration#timeouts</url>
    <fullTitle>WebTau: Advanced Configuration, Timeouts [UI]</fullTitle>
    <text>
      <text>Default timeout in milliseconds for waitTo and waitToNot waitTimeout = 25000 --waitTimeout=25000</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/advanced-configuration#window-size</url>
    <fullTitle>WebTau: Advanced Configuration, Window Size [UI]</fullTitle>
    <text>
      <text>Browser window size can be set using windowWidth and windowHeight url = "http://localhost:8180" windowWidth = 1280 windowHeight = 800</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/advanced-configuration#documentation-artifacts</url>
    <fullTitle>WebTau: Advanced Configuration, Documentation Artifacts [UI]</fullTitle>
    <text>
      <text>By default all generated documentation artifacts (e.g. screenshots) are created in the current directory. To override url = "http://localhost:8180" docPath = "screenshots"</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/local-storage#access-local-storage</url>
    <fullTitle>WebTau: Local Storage, Access Local Storage [UI]</fullTitle>
    <text>
      <text>To access local storage use browser.localStorage .Lets consider a simple web page that displays a value from a local storage. &lt;div id="favorite-color"> &lt;/div> &lt;script> const element = document.getElementById('favorite-color'); element.innerHTML = localStorage.getItem('favoriteColor'); &lt;/script> package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("local storage api") { browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'clean') def color = $('#favorite-color') browser.reopen('/local-storage') color.should == 'clean' browser.localStorage.clear() browser.reopen('/local-storage') color.should == '' } public String getItem(String key) public void setItem(String key, String value) public String removeItem(String key) public void clear() public int size()</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#open</url>
    <fullTitle>WebTau: Navigation, Open [UI]</fullTitle>
    <text>
      <text>To open a page use browser.open . Browser will load a page only if the current url doesn't match the passed one. search.submit('query') browser.open("/search") // page is not be ing refreshed search.searchMessage.should == 'searching for query' Note: relative url will be automatically expanded to the full url based on the UI/basic-configuration configuration</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#reopen</url>
    <fullTitle>WebTau: Navigation, Reopen [UI]</fullTitle>
    <text>
      <text>Use brower.reopen to force open the page even if the page url already matches the passed one. search.submit('name') browser.reopen("/search") // page is going to be refreshed search.searchMessage.should == ''</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#refresh</url>
    <fullTitle>WebTau: Navigation, Refresh [UI]</fullTitle>
    <text>
      <text>Use browser.refresh to refresh current page. search.submit('name') browser.reopen("/search") // page is going to be refreshed search.searchMessage.should == ''</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#restart</url>
    <fullTitle>WebTau: Navigation, Restart [UI]</fullTitle>
    <text>
      <text>Use browser.restart to restart a browser and open last opened url. browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'pretty') browser.refresh() $('#favorite-color').should == 'pretty' browser.restart() $('#favorite-color').should == '' Note: restarting creates a clean instance of a browser. Local storage is going to be reset.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#assert-url</url>
    <fullTitle>WebTau: Navigation, Assert URL [UI]</fullTitle>
    <text>
      <text>Use browser.url to assert on or wait for url changes. http://example.com/resource/id?type=full&amp;debug=true#subId</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/navigation#persist-url</url>
    <fullTitle>WebTau: Navigation, Persist URL [UI]</fullTitle>
    <text>
      <text>Use browser.saveCurrentUrl to save url in a local cache and browser.openSavedUrl to open a page later.It can be handy in multipart tests where first part creates an entity and the second part updates the created entity. browser.open('/resource-creation') $('#new').click() browser.saveCurrentUrl() In order to simplify tests development of a second part you can run first part once, save URL, and iterate on a second part by opening a page using saved URL. browser.openSavedUrl() // continue resource related manipulations Note: url is stored in a local cache file and will survive tests restart.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-open-handlers#implicit-page-open-logic</url>
    <fullTitle>WebTau: Page Open Handlers, Implicit Page Open Logic [UI]</fullTitle>
    <text>
      <text>You can register a custom callback that will be called implicitly every time a web page is opened. One of the typical use cases is to inject cookies or values into a local storage before tests logic begins.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/page-open-handlers#auto-login</url>
    <fullTitle>WebTau: Page Open Handlers, Auto Login [UI]</fullTitle>
    <text>
      <text>To register an open handler you need to define browserPageNavigationHandlerProvider config value. url = "http://localhost:8180" def userNameKey = 'userName' browserPageNavigationHandler = { passedUrl, fullUrl, currentUrl -> if (browser.localStorage.getItem(userNameKey)) { return } browser.localStorage.setItem(userNameKey, 'LoggedIn User') browser.reopen(fullUrl) } package scenarios.ui import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("page open handlers") { browser.open('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } scenario("page open handlers during re-open") { browser.localStorage.clear() browser.reopen('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } Note: usage of localStorage is just an example. You can use cookies , call external services using http. or load credentials from a file system.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/finders-and-filters#finders</url>
    <fullTitle>WebTau: Finders And Filters, Finders [UI]</fullTitle>
    <text>
      <text>Finders in webtau is the initial web element selection that could select one or more elements.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/finders-and-filters#by-css</url>
    <fullTitle>WebTau: Finders And Filters, By CSS [UI]</fullTitle>
    <text>
      <text>Use $ to select an element by a given css selector. def welcomeMessage = $('#welcome') welcomeMessage.should == 'hello' If more than one element is matched, the first one will be used for actions and assertions. def menu = $('ul li a') menu.should == 'book' While click and sendKeys will always work on a first element only, the matchers can work with a list of things. def menu = $('ul li a') menu.should == ['book', 'orders', 'help'] Note: declaring element this way will not trigger element search right away.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/finders-and-filters#filters</url>
    <fullTitle>WebTau: Finders And Filters, Filters [UI]</fullTitle>
    <text>
      <text>You can use filters to narrow down elements selected by finders like css .Filter comes in a way of get method. Parameter is one of the followingElement numberElement textElement regexp def ordersMenu = $('ul li a').get(2) ordersMenu.should == 'orders' def ordersMenu = $('ul li a').get('orders') ordersMenu.should == 'orders' def ordersMenu = $('ul li a').get(~/ord/) ordersMenu.should == 'orders'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/finders-and-filters#chaining</url>
    <fullTitle>WebTau: Finders And Filters, Chaining [UI]</fullTitle>
    <text>
      <text>After you filtered, you can use finders again to find nested elements. def ordersMenu = $('ul li').get(2).find('a') ordersMenu.should == 'orders'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/matchers#text</url>
    <fullTitle>WebTau: Matchers, Text [UI]</fullTitle>
    <text>
      <text>def message = $('#message') message.should == 'Select option' def message = $('#message') message.should == ~/option/ def menu = $('#menu ul li') menu.should == ['Hello', 'Text', 'World'] def menu = $('#menu ul li') menu.should == ['Hello', ~/T..t/, 'World']</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/matchers#numbers</url>
    <fullTitle>WebTau: Matchers, Numbers [UI]</fullTitle>
    <text>
      <text>def total = $('#total') total.should == 300.6 def total = $('#total') total.shouldBe > 200 def total = $('#total') total.shouldBe >= 300 def split = $('#split ul li') split.should == [100, 28, 172.6] def split = $('#split ul li') split.should == [100, lessThan(100), greaterThanOrEqual(150)]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/UI/matchers#state</url>
    <fullTitle>WebTau: Matchers, State [UI]</fullTitle>
    <text>
      <text>def button = $("#action") button.should beDisabled() button.shouldNot beEnabled() def feedback = $("#feedback") feedback.should beHidden() feedback.shouldNot beVisible() &lt;div> &lt;button id="action" disabled>Click me&lt;/button> &lt;div id="feedback" style="display: none;">&lt;/div> &lt;/div></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/data-driven-scenarios#dynamic-scenarios</url>
    <fullTitle>WebTau: Data Driven Scenarios, Dynamic Scenarios [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Every time you call scenario method a new scenario is being registered. Define scenarios in a loop to have dynamic scenarios based on provided data. package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* [1, 2, 3].each { number -> scenario("number $number") { println number } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/data-driven-scenarios#csv</url>
    <fullTitle>WebTau: Data Driven Scenarios, CSV [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Use data.csv to conveniently build your scenarios from an external CSV data set. title, input, output hello, 10, 20 world, 30, 40 package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* data.csv('use-cases.csv').each { row -> scenario("use case ${row.title}") { println row.input println row.output } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/data-driven-scenarios#table-data</url>
    <fullTitle>WebTau: Data Driven Scenarios, Table Data [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Use TableData If you want to derive data and/or have a convenience of collocating data and tests package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* def lever = 10 def useCases = ['title' | 'input' | 'output'] { ____________________________________ 'hello' | lever | lever + 10 'world' | lever + 30 | lever + 40 } useCases.each { row -> scenario("use case ${row.title}") { println row.input println row.output } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/tests-hard-stops#terminate-all</url>
    <fullTitle>WebTau: Tests Hard Stops, Terminate All [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Use terminateAll if you need to stop a current scenario and all the scenarios after that. Consequent scenarios will be marked as skipped in the produced report. package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* scenario("first test") { terminateAll('hard stop of the rest of the tests') } scenario("second test") { browser.open("/app") } scenario("third test") { http.get("/weather") { temperature.shouldBe &lt; 100 } } Test two and three in the example above will not be executed. Browser will not be opened and REST API will not be called.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/selective-run#sscenario</url>
    <fullTitle>WebTau: Selective Run, sscenario [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Define tests with sscenario or singleScenario to only run those tests and skip all the other tests defined in all the test files. Useful during tests creation or debugging. package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* scenario('step one') { http.post('/reset') { // ... } } sscenario('step two') { // test that you want to focus on } singleScenario('step three') { // test that you want to focus on } scenario('step four') { http.put('/extra') { // ... } } Note: webtau command line will exit with non zero code if there are sscenario tests present</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/skipping-tests#skipping-tests-on-condition</url>
    <fullTitle>WebTau: Skipping Tests, Skipping Tests on Condition [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Use onlyWhen if you need to skip tests based on a condition. package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* String emailHost = cfg.emailHost onlyWhen('email server is internal', { -> emailHost.contains('internal.server')}) { scenario('confirmation emails should be sent') { // ... http.get(emailHost) { subjects.should contain('my message') } } } Tests will still appear as part of your report but will be marked as skipped.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/skipping-tests#skipping-tests-based-on-env</url>
    <fullTitle>WebTau: Skipping Tests, Skipping Tests Based on Env [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Use onlyForEnv shortcut if you need to skip tests for certain environment. package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* onlyForEnv('experimental') { scenario('this scenario will only be executed in "experimental" env') { http.get('/new-endpoint') { price.shouldBe > 0 } } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/skipping-tests#custom-shortcuts</url>
    <fullTitle>WebTau: Skipping Tests, Custom Shortcuts [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Consider creating your project specific shortcuts to avoid boilerplate. Here is an example of onlyForEnv shortcut definition.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/groovy-specific-runner/skipping-tests#unconditionally-skipping-tests</url>
    <fullTitle>WebTau: Skipping Tests, Unconditionally Skipping Tests [Groovy Specific Runner]</fullTitle>
    <text>
      <text>Instead of scenario , use dscenario or disabledScenario to always skip a test. This is analogous to Junit's @Ignore or @Disabled . package scenarios.concept import static com.twosigma.webtau.WebTauGroovyDsl.* dscenario('do not execute this scenario') { http.get('/new-endpoint') { price.shouldBe > 0 } } disabledScenario('do not execute this scenario either') { http.get('/new-endpoint') { price.shouldBe > 0 } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/generic-runners/JUnit-4#webtau-runner</url>
    <fullTitle>WebTau: JUnit 4, WebTau Runner [Generic Runners]</fullTitle>
    <text>
      <text>You can use webtau http. and browser. methods as in a junit test, but to enable reporting you need to use @RunWith(WebTauRunner.class) Groovy package com.example.tests.junit4 import com.twosigma.webtau.junit4.WebTauRunner import org.junit.Test import org.junit.runner.RunWith import static com.twosigma.webtau.WebTauDsl.* @RunWith(WebTauRunner.class) class CustomerCrudSingleGroovyTest { private def customerPayload = [firstName: 'FN', lastName: 'LN'] private def changedCustomerPayload = [*:customerPayload, lastName: 'NLN'] @Test void crud() { def id = http.post("/customers", customerPayload) { return id } http.get("/customers/$id") { body.should == customerPayload } http.put("/customers/$id", changedCustomerPayload) { body.should == changedCustomerPayload } http.get("/customers/$id") { body.should == changedCustomerPayload } http.delete("/customers/$id") { statusCode.should == 204 } http.get("/customers/$id") { statusCode.should == 404 } } } Java package com.example.tests.junit4; import com.twosigma.webtau.junit4.WebTauRunner; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import java.util.Map; import static com.twosigma.webtau.Ddjt.aMapOf; import static com.twosigma.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class CustomerCrudSingleJavaTest { private Map&lt;String, Object> customerPayload = createCustomerPayload(); private Map&lt;String, Object> changedCustomerPayload = createChangedCustomerPayload(); @BeforeClass public static void setUpClass() { String port = System.getProperty("springboot.http.port", "8080"); getCfg().setBaseUrl("http://localhost:" + port); } @Test public void crud() { int id = http.post("/customers", customerPayload, ((header, body) -> { return body.get("id"); })); http.get("/customers/" + id, ((header, body) -> { body.should(equal(customerPayload)); })); http.put("/customers/" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get("/customers/" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.delete("/customers/" + id, ((header, body) -> { header.statusCode().should(equal(204)); })); http.get("/customers/" + id, ((header, body) -> { header.statusCode().should(equal(404)); })); } private Map&lt;String, Object> createCustomerPayload() { return aMapOf( "firstName", "FN", "lastName", "LN"); } private Map&lt;String, Object> createChangedCustomerPayload() { Map&lt;String, Object> payload = createCustomerPayload(); payload.put("lastName", "NLN"); return payload; } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/generic-runners/JUnit-4#maven-import</url>
    <fullTitle>WebTau: JUnit 4, Maven Import [Generic Runners]</fullTitle>
    <text>
      <text>&lt;dependency> &lt;groupId>com.twosigma.webtau&lt;/groupId> &lt;artifactId>webtau-junit4&lt;/artifactId> &lt;version>1.5&lt;/version> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/cli#overrides</url>
    <fullTitle>WebTau: Cli, Overrides [Configuration]</fullTitle>
    <text>
      <text>Any config file parameter can be overridden with a command line parameter.For example, given this config file: cfg waitTimeout = 2500 url = http://my-server Values can be overridden as follows: webtau --waitTimeout=25000 --url=http://another-server</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/environments#select</url>
    <fullTitle>WebTau: Environments, Select [Configuration]</fullTitle>
    <text>
      <text>cfg waitTimeout = 2500 url = http://my-server environments { dev { url = "http://localhost:8080" } } webtau --env=dev</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/options#cli-and-configuration-file-options</url>
    <fullTitle>WebTau: Options, CLI and configuration file options [Configuration]</fullTitle>
    <text>
      <text>name description default value chromeBinPath path to chrome binary chromeDriverPath path to chrome driver binary config config file path webtau.cfg docPath path for screenshots and other generated artifacts for documentation ${workingDir} env environment id local headless run headless mode false interactive use CLI interactive mode false jsonSchemasDir url of directory containing JSON schemas noColor disable ANSI colors false numberOfThreads number of threads on which to run test files (one file per thread) 1 openApiIgnoreAdditionalProperties ignore additional OpenAPI properties false openApiSpecUrl url of OpenAPI 2 spec against which to validate http calls reportPath report file path ${workingDir}/webtau.report.html staleElementRetry number of times to automatically retry for stale element actions 5 url base url for application under test verbosityLevel output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etc 2147483647 waitTimeout wait timeout in milliseconds 5000 windowHeight browser window height 800 windowWidth browser window width 1000 workingDir logical working dir</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/webtau/guide/configuration/options#environment-variable-options</url>
    <fullTitle>WebTau: Options, Environment variable options [Configuration]</fullTitle>
    <text>
      <text>environment variable description default value WEBTAU_CHROME_BIN_PATH path to chrome binary WEBTAU_CHROME_DRIVER_PATH path to chrome driver binary WEBTAU_CONFIG config file path webtau.cfg WEBTAU_DOC_PATH path for screenshots and other generated artifacts for documentation ${workingDir} WEBTAU_ENV environment id local WEBTAU_HEADLESS run headless mode false WEBTAU_INTERACTIVE use CLI interactive mode false WEBTAU_JSON_SCHEMAS_DIR url of directory containing JSON schemas WEBTAU_NO_COLOR disable ANSI colors false WEBTAU_NUMBER_OF_THREADS number of threads on which to run test files (one file per thread) 1 WEBTAU_OPEN_API_IGNORE_ADDITIONAL_PROPERTIES ignore additional OpenAPI properties false WEBTAU_OPEN_API_SPEC_URL url of OpenAPI 2 spec against which to validate http calls WEBTAU_REPORT_PATH report file path ${workingDir}/webtau.report.html WEBTAU_STALE_ELEMENT_RETRY number of times to automatically retry for stale element actions 5 WEBTAU_URL base url for application under test WEBTAU_VERBOSITY_LEVEL output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etc 2147483647 WEBTAU_WAIT_TIMEOUT wait timeout in milliseconds 5000 WEBTAU_WINDOW_HEIGHT browser window height 800 WEBTAU_WINDOW_WIDTH browser window width 1000 WEBTAU_WORKING_DIR logical working dir</text>
      <score>STANDARD</score>
    </text>
  </entry>
</mdoc>
